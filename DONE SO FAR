ESP32 – CLIENT	
1) Collegamento con access point (altra ESP32) attraverso funzioni di base della scheda.
2) Chiamata alla funzione get_and_set_time () che imposta la variabile globale local_clock con il clock della esp32 in quel momento, dunque chiede al server il suo clock e setta la variabile globale server_clock con il clock del server appena preso.
3) Inizio del loop.
4) SNIFFER TURN (7s): appena sniffa un pacchetto probe_request crea una stringa contenente l’rssi, il source MAC, il seq_n del pacchetto e il timestamp relativo del pacchetto (il timestamp relativo è dato dalla somma del server_clock con la differenza tra il timestamp del pacchetto e la variabile local_clock). Dunque aggiunge la stringa al buffer globale send_out_buff.
5) CLIENT TURN (3s): Invia al server la dimensione del buffer globale. Se tale dimensione è maggiore di 500 byte, la divide in chunk da 500 byte, dopodiché invia il buffer al server. Dunque legge la risposta del server che contiene il clock del server e aggiorna la variabile server_clock.

ESP32 – ACCESS POINT
1) Fa da access point. A quanto pare non regge più di 500 byte per volta.

PC – SERVER
1) Crea un file contenente una lista di tutti i MAC delle esp32 collegate al server (si ricrea ogni volta che il server viene avviato)
2) Ciclo while infinito.
3) Se il MAC della esp32 che si collega non è già nella lista, lo si mette in lista e si crea un file proprio dell’esp32.
4) Se il server riceve il protocollo per la richiesta del server_clock da parte di una esp32, invia il proprio clock.
5) Altrimenti legge il buffer inviato dalla esp32 e lo scrive nel file ad esso dedicato.

PC – DATA ANALYZER
1) Apre il file contenente la lista dei MAC delle esp32 connesse.
2) In un ciclo infinito prende ogni MAC e gestisce per ciascuno di essi un thread a parte dove apre tali file e li analizza. Il ciclo è infinito poiché l’algoritmo deve prendere i MAC anche se una esp32 viene collegata dopo.
3) Per ogni thread (quindi per ogni esp32) la funzione analyzer () apre il file proprio dell’esp32 a cui è riferita e, in un ciclo infinito (per lo stesso motivo di sopra), gestisce ogni riga del file, creando un oggetto User per ogni MAC source, e aggiungendo ad esso il relativo timestamp e rssi (non esisteranno quindi diversi User con lo stesso MAC, ma lo stesso User potrà avere diversi timestamp e rssi).

BISOGNA AGGIUNGERE L'HASH DEL PACCHETTO!!!
